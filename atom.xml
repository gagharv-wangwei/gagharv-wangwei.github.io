<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gagharv</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangweizZZ.github.io/"/>
  <updated>2020-06-29T09:15:04.547Z</updated>
  <id>http://wangweizZZ.github.io/</id>
  
  <author>
    <name>wang wei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Disruptor</title>
    <link href="http://wangweizZZ.github.io/2020/06/26/Disruptor/"/>
    <id>http://wangweizZZ.github.io/2020/06/26/Disruptor/</id>
    <published>2020-06-26T07:53:14.000Z</published>
    <updated>2020-06-29T09:15:04.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Disruptor 环形缓冲队列，可用于<strong>生产者-消费者</strong>模型下的高性能队列使用</p><p>在<strong>生产者-消费者</strong>模型下</p><ul><li>生产者不停地往队列里面生产新的需要处理的任务</li><li>消费者不停地从队列里面处理掉这些任务</li></ul><p>为了保证多线程并发访问下的数据准确性，通常我们可以需要借助锁或者直接使用基于锁的线程安全集合，如<code>ArrayBlockingQueue</code>，<code>LinkedBlockingQueue</code>等。</p><p>而Disruptor能够提供极细粒度的CAS甚至无锁化的队列，并针对CPU指令做了一些性能优化，从而大大提高了性能</p><h2 id="RingBuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a>RingBuffer</h2><p>基于数组的环形缓冲区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bufferSize - 1 用于内存位置计算</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> indexMask;</span><br><span class="line"><span class="comment">//数据 基于数组实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object[] entries;</span><br><span class="line"><span class="comment">//缓冲区大小</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> bufferSize;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Sequencer sequencer;</span><br></pre></td></tr></table></figure><p>RingBuffer 创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RingBuffer.create(</span><br><span class="line">        ProducerType producerType,</span><br><span class="line">        EventFactory&lt;E&gt; factory,</span><br><span class="line">        <span class="keyword">int</span> bufferSize,</span><br><span class="line">        WaitStrategy waitStrategy</span><br></pre></td></tr></table></figure><p>ProducerType</p><ul><li>SINGLE 单生产者模式</li><li>MULTI 多生产者模式</li></ul><p>EventFactory 事件工厂,初始化RingBuffer 时需要将对象填充到数组中</p><p>WaitStrategy 消费者消费的阻塞策略</p><h2 id="Sequencer"><a href="#Sequencer" class="headerlink" title="Sequencer"></a>Sequencer</h2><p>核心类，协调写入和读取</p><blockquote><p>存储写入进度相关</p></blockquote><blockquote><p>其抽象实现类<code>AbstractSequencer</code> 通过维护<br>消费者进度 <code>Sequence[]</code>来影响写入（消费者未及时消费导致队列满了，则阻塞写入）</p></blockquote><blockquote><p>SequenceBarrier 通过持有Sequencer从而控制消费者消费</p></blockquote><ul><li><p>SingleProducerSequencer<br>单生产者,单生产者的情况下，不需要像多线程那样去CAS竞争判断</p></li><li><p>MultiProducerSequencer<br>多生产者</p></li></ul><h3 id="SingleProducerSequencer"><a href="#SingleProducerSequencer" class="headerlink" title="SingleProducerSequencer"></a>SingleProducerSequencer</h3><p>使用基本类型long去缓存 nextValue、cachedValue 即游标信息</p><p>发布事件通过<code>cursor</code> 记录位置</p><h3 id="MultiProducerSequencer"><a href="#MultiProducerSequencer" class="headerlink" title="MultiProducerSequencer"></a>MultiProducerSequencer</h3><p>使用Sequence对象去缓存 nextValue、cachedValue 即游标信息<br>且在获取的时候需要CAS判断竞争</p><p>发布事件通过<code>availableBuffer</code> 记录位置</p><h2 id="生产数据"><a href="#生产数据" class="headerlink" title="生产数据"></a>生产数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取序号</span></span><br><span class="line"><span class="keyword">long</span> sequence = ringBuffer.next();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 2.取出空队列</span></span><br><span class="line">    LongEvent longEvent = ringBuffer.get(sequence);</span><br><span class="line">    <span class="comment">// 3.给空队列赋值</span></span><br><span class="line">    longEvent.setValue(byteBuffer.getLong(<span class="number">0</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 4.发布数据</span></span><br><span class="line">    ringBuffer.publish(sequence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取sequenceId<br><code>gatingSequences</code> 是消费者Sequence集合sequenceId<br>通过对比消费者进度，当队列满了的时候执行 阻塞获取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (wrapPoint &gt; (minSequence = Util.getMinimumSequence(gatingSequences, nextValue)))</span><br><span class="line">&#123;</span><br><span class="line">    LockSupport.parkNanos(<span class="number">1L</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="消费数据"><a href="#消费数据" class="headerlink" title="消费数据"></a>消费数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(</span><br><span class="line">        longEventFactory, ringbuffer, executor,</span><br><span class="line">        ProducerType.SINGLE, <span class="keyword">new</span> BlockingWaitStrategy()</span><br><span class="line">    );</span><br><span class="line">disruptor.handleEventsWith(<span class="keyword">new</span> EventHandler&lt;LongEvent&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(LongEvent longEvent, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"消费者获得数据:"</span> + longEvent.getValue());</span><br><span class="line">    &#125;&#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// longEventDisruptor.handleEventsWithWorkerPool(new WorkHandler&lt;LongEvent&gt;() &#123;</span></span><br><span class="line"><span class="comment">//     @Override</span></span><br><span class="line"><span class="comment">//         public void onEvent(LongEvent longEvent) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;);</span></span><br><span class="line">disruptor.start()</span><br></pre></td></tr></table></figure><p>消费者们通过<code>SequenceBarrier</code>获取事件</p><p>通过向 Disruptor 对象的<code>ConsumerRepository</code>上绑定处理逻辑，<code>start()</code>后触发消费者线程消费</p><ul><li><p>BatchEventProcessor<br>广播事件</p></li><li><p>WorkProcessor<br>仅仅向同一组消费者之一发送</p></li></ul><p><img src="/images/disrputor/disruptor-1-1.jpeg" alt="流程图"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="缓存行填充"><a href="#缓存行填充" class="headerlink" title="缓存行填充"></a>缓存行填充</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RingBufferPad</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/disrputor/disruptor-1-2.png" alt="缓冲行"></p><p>为了增加<strong>CPU Cache</strong>的缓存命中率从而提高性能，添加缓冲行，避免由于其他变量的变化而影响到目标变量的缓存失效</p><blockquote><p>命中CPU L1、L2、L3 1ns~20ns ，未命中 则需要 80ns左右</p></blockquote><h3 id="CPU指令"><a href="#CPU指令" class="headerlink" title="CPU指令"></a>CPU指令</h3><p>Disruptor 有很多UNSAFE的指令级别操作</p><p>如 <code>UNSAFE.putOrderedInt</code>,<code>UNSAFE.putLongVolatile</code> 去控制内存屏障等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Disruptor 环形缓冲队列，可用于&lt;strong&gt;生产者-消费者&lt;/strong&gt;模型下的高性能队列使用&lt;/p&gt;
&lt;p&gt;在&lt;stron
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wangweizZZ.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="高性能" scheme="http://wangweizZZ.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Nacos 配置中心-逻辑架构</title>
    <link href="http://wangweizZZ.github.io/2020/04/27/Nacos-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/"/>
    <id>http://wangweizZZ.github.io/2020/04/27/Nacos-配置中心-逻辑架构/</id>
    <published>2020-04-27T08:40:52.000Z</published>
    <updated>2020-04-27T09:03:55.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nacos-配置中心介绍"><a href="#Nacos-配置中心介绍" class="headerlink" title="Nacos 配置中心介绍"></a>Nacos 配置中心介绍</h1><p><img src="/images/nacos/nacos-1-2.png" alt="nacos"></p><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>Nacos配置信息存储于<code>mysql</code>中，节点启动的时候会加载执行<code>DumpAllTask</code>等任务将数据加载进本地文件，而后记录md5值写入内存中</p><blockquote><p>内存存储MD5用于比对数据变更，文件存储配置信息，mysql用于保证数据可靠性</p></blockquote><h2 id="客户端数据获取"><a href="#客户端数据获取" class="headerlink" title="客户端数据获取"></a>客户端数据获取</h2><p>客户端监听配置变更只检查自身的配置md5是否与服务端<code>CACHE</code>中的md5相同，如果不同则从本地文件中获取配置内容，即<code>Mysql</code>不参与客户端配置获取的流程</p><blockquote><p>客户端数据获取只和CACHE和File有关，避免了mysql查询的耗时以及可靠性依赖</p></blockquote><h2 id="配置变更"><a href="#配置变更" class="headerlink" title="配置变更"></a>配置变更</h2><p>服务端接受到配置变更</p><ol><li>写入数据库</li><li>向多有节点（包括自己）发送数据变更事件（如果有服务端挂了，则对应的服务端请求写入队列延后定期发送）</li><li>客户端接收到事件变更提交一个<code>dumpTask</code>给<code>TaskManager</code></li><li><code>TaskManager</code>定期检查事件，执行<code>dumpTask</code> 从mysql更新对应配置信息到文件以及内存中，并触发<code>LocalDataChangeEvent</code>事件</li><li><code>LongPollingService</code>订阅了<code>LocalDataChangeEvent</code>事件，执行<code>DataChangeTask</code>任务，检查自身维护的<code>allSubs</code>（客户端请求列表）是否需要推送变更数据</li></ol><blockquote><p>服务端是无状态的，配置的写入只需要保证写入mysql然后通知各自从mysql加载最新数据即可，由此客户端获取可能存在延迟</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nacos-配置中心介绍&quot;&gt;&lt;a href=&quot;#Nacos-配置中心介绍&quot; class=&quot;headerlink&quot; title=&quot;Nacos 配置中心介绍&quot;&gt;&lt;/a&gt;Nacos 配置中心介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/nacos/nacos-
      
    
    </summary>
    
      <category term="云原生" scheme="http://wangweizZZ.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
      <category term="nacos" scheme="http://wangweizZZ.github.io/tags/nacos/"/>
    
  </entry>
  
  <entry>
    <title>Nacos 配置中心--配置推送</title>
    <link href="http://wangweizZZ.github.io/2020/04/21/Nacos-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83-%E9%85%8D%E7%BD%AE%E6%8E%A8%E9%80%81/"/>
    <id>http://wangweizZZ.github.io/2020/04/21/Nacos-配置中心-配置推送/</id>
    <published>2020-04-21T10:13:03.000Z</published>
    <updated>2020-04-27T08:32:43.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nacos-配置推送"><a href="#Nacos-配置推送" class="headerlink" title="Nacos 配置推送"></a>Nacos 配置推送</h2><h3 id="配置获取"><a href="#配置获取" class="headerlink" title="配置获取"></a>配置获取</h3><p><strong>Nacos 采取长轮询的方式定期获取配置变更</strong></p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p><img src="/images/nacos/nacos-1-1.png" alt="nacos"><br>如图，客户端 维护一个<code>ClientWorker</code>类定期（默认每隔10ms) 去服务端获取配置变更事件<br>服务端获取到请求后将请求绑定到<code>LongPollingService#allSubs</code>上，如果发生数据变更事件后检查allSubs即可获取客户端列表并返回结果</p><blockquote><p>服务端存在两种阻塞方式</p><ul><li>当isFixedPolling=true时，服务端始终等超时执行asyncTimeoutFuture进行数据检查并返回变更数据</li><li>当isFixedPolling=false时(默认），服务端一旦配置变更，立即触发数据变更，并取消asyncTimeoutFuture</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientLongPolling</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           asyncTimeoutFuture = scheduler.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       ...</span><br><span class="line">                       <span class="comment">//移除订阅关系</span></span><br><span class="line">                       allSubs.remove(ClientLongPolling.<span class="keyword">this</span>);</span><br><span class="line">                       <span class="comment">//如果是固定轮询，则即便时间内收到配置变更也不返回，又该future到时间统一检查数据是否变更</span></span><br><span class="line">                       <span class="keyword">if</span> (isFixedPolling()) &#123;</span><br><span class="line">                           ...</span><br><span class="line">                           <span class="keyword">if</span> (changedGroups.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                               sendResponse(changedGroups);</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               sendResponse(<span class="keyword">null</span>);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                          ...</span><br><span class="line">                          <span class="comment">//非固定轮询，由配置变更事件返回变更，此处超时不检查数据是否变更</span></span><br><span class="line">                           sendResponse(<span class="keyword">null</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                      ...</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, timeoutTime, TimeUnit.MILLISECONDS);</span><br><span class="line">           <span class="comment">//绑定到allSubs上</span></span><br><span class="line">           allSubs.add(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>服务端接收到配置修改的请求，写入数据库而后触发<code>ConfigDataChangeEvent</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 写入数据库</span></span><br><span class="line">persistService.insertOrUpdate(srcIp, srcUser, configInfo, time, configAdvanceInfo, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//2. 触发 ConfigDataChangeEvent</span></span><br><span class="line">EventDispatcher.fireEvent(<span class="keyword">new</span> ConfigDataChangeEvent(<span class="keyword">false</span>, dataId, group, tenant, time.getTime()));</span><br></pre></td></tr></table></figure></p><p>AsyncNotifyService 订阅了<code>ConfigDataChangeEvent</code>事件，依次向所有服务端发送数据库变更事件，促使所有服务端从mysql更新数据，并检查各自<code>allSubs</code>连接的客户端，返回response<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (event <span class="keyword">instanceof</span> ConfigDataChangeEvent) &#123;</span><br><span class="line">    ConfigDataChangeEvent evt = (ConfigDataChangeEvent) event;</span><br><span class="line">    ...</span><br><span class="line">    Queue&lt;NotifySingleTask&gt; queue = <span class="keyword">new</span> LinkedList&lt;NotifySingleTask&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ipList.size(); i++) &#123;</span><br><span class="line">        queue.add(<span class="keyword">new</span> NotifySingleTask(dataId, group, tenant, tag, dumpTs, (String) ipList.get(i), evt.isBeta));</span><br><span class="line">    &#125;</span><br><span class="line">    EXECUTOR.execute(<span class="keyword">new</span> AsyncTask(httpclient, queue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>综上: 客户端定期轮询拉取等待返回结果，服务端在轮询周期内等待数据变更事件，如发生则立刻返回已达到配置变更后尽快获取到配置变更的效果</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Nacos-配置推送&quot;&gt;&lt;a href=&quot;#Nacos-配置推送&quot; class=&quot;headerlink&quot; title=&quot;Nacos 配置推送&quot;&gt;&lt;/a&gt;Nacos 配置推送&lt;/h2&gt;&lt;h3 id=&quot;配置获取&quot;&gt;&lt;a href=&quot;#配置获取&quot; class=&quot;head
      
    
    </summary>
    
      <category term="云原生" scheme="http://wangweizZZ.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
      <category term="nacos" scheme="http://wangweizZZ.github.io/tags/nacos/"/>
    
  </entry>
  
  <entry>
    <title>Nacos 配置中心--服务启动</title>
    <link href="http://wangweizZZ.github.io/2020/04/19/Nacos-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83-%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/"/>
    <id>http://wangweizZZ.github.io/2020/04/19/Nacos-配置中心-服务启动/</id>
    <published>2020-04-19T12:40:14.000Z</published>
    <updated>2020-04-27T08:38:52.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nacos-启动流程"><a href="#Nacos-启动流程" class="headerlink" title="Nacos 启动流程"></a>Nacos 启动流程</h1><p>nacos启动主要流程包含:</p><p>读取配置文件 ⟹ 将数据库中存储的配置信息写入本地文件 ⟹  开启一些定时任务用于数据定期比对，清理等</p><blockquote><p>nacos console 启动日志 位于  {NACOSHOME}/logs/nacos.log<br>nacos config 启动日志 位于 {NACOSHOME}/logs/config-server.log</p></blockquote><h2 id="1-配置信息读取"><a href="#1-配置信息读取" class="headerlink" title="1. 配置信息读取"></a>1. 配置信息读取</h2><p><code>StartingSpringApplicationRunListener</code> 打印启动信息<br>同时通过调用<code>SystemUtils</code>触发初始化<code>InetUtils</code>静态初始化触发PropertyUtil静态初始化从而触发配置属性加载<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String baseDir = System.getProperty(<span class="string">"nacos.home"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(baseDir)) &#123;</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(baseDir + <span class="string">"/conf/application.properties"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        inputStream = PropertyUtil.class</span><br><span class="line">            .getResourceAsStream(<span class="string">"/application.properties"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    properties.load(inputStream);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">"read property file error:"</span> + e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    IOUtils.closeQuietly(inputStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-数据加载"><a href="#2-数据加载" class="headerlink" title="2. 数据加载"></a>2. 数据加载</h2><p>核心类<code>DumpService</code><br>负责初始化加载数据库中的配置信息，将配置信息写入本地文件，以及生成md5值写如内存<br>客户端通过比对内存的md5值即可发现配置是否变更，如过变更则通过本地文件获取最新配置，无需查询数据库<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LogUtil.defaultLog.warn(<span class="string">"DumpService start"</span>);</span><br><span class="line">    DumpProcessor processor = <span class="keyword">new</span> DumpProcessor(<span class="keyword">this</span>);</span><br><span class="line">    DumpAllProcessor dumpAllProcessor = <span class="keyword">new</span> DumpAllProcessor(<span class="keyword">this</span>);</span><br><span class="line">    DumpAllBetaProcessor dumpAllBetaProcessor = <span class="keyword">new</span> DumpAllBetaProcessor(<span class="keyword">this</span>);</span><br><span class="line">    DumpAllTagProcessor dumpAllTagProcessor = <span class="keyword">new</span> DumpAllTagProcessor(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于处理配置变更任务的管理器</span></span><br><span class="line">    dumpTaskMgr = <span class="keyword">new</span> TaskManager(<span class="string">"com.alibaba.nacos.server.DumpTaskManager"</span>);</span><br><span class="line">    dumpTaskMgr.setDefaultTaskProcessor(processor);</span><br><span class="line">    <span class="comment">//用于处理定时dump数据的任务管理器</span></span><br><span class="line">    dumpAllTaskMgr = <span class="keyword">new</span> TaskManager(<span class="string">"com.alibaba.nacos.server.DumpAllTaskManager"</span>);</span><br><span class="line">    dumpAllTaskMgr.setDefaultTaskProcessor(dumpAllProcessor);</span><br><span class="line">    <span class="comment">// ？？？此处感觉缺了 dumpAllTaskMgr.addProcessor(DumpAllBetaTask.TASK_ID,dumpAllBetaProcessor);</span></span><br><span class="line">    Runnable dumpAll = () -&gt; dumpAllTaskMgr.addTask(DumpAllTask.TASK_ID, <span class="keyword">new</span> DumpAllTask());</span><br><span class="line">    Runnable dumpAllBeta = () -&gt; dumpAllTaskMgr.addTask(DumpAllBetaTask.TASK_ID, <span class="keyword">new</span> DumpAllBetaTask());</span><br><span class="line"></span><br><span class="line">    Runnable clearConfigHistory = () -&gt; &#123;</span><br><span class="line">        log.warn(<span class="string">"clearConfigHistory start"</span>);</span><br><span class="line">        <span class="keyword">if</span> (ServerListService.isFirstIp()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Timestamp startTime = getBeforeStamp(TimeUtils.getCurrentTime(), <span class="number">24</span> * getRetentionDays());</span><br><span class="line">                <span class="keyword">int</span> totalCount = persistService.findConfigHistoryCountByTime(startTime);</span><br><span class="line">                <span class="keyword">if</span> (totalCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> pageSize = <span class="number">1000</span>;</span><br><span class="line">                    <span class="keyword">int</span> removeTime = (totalCount + pageSize - <span class="number">1</span>) / pageSize;</span><br><span class="line">                    log.warn(<span class="string">"clearConfigHistory, getBeforeStamp:&#123;&#125;, totalCount:&#123;&#125;, pageSize:&#123;&#125;, removeTime:&#123;&#125;"</span>,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;startTime, totalCount, pageSize, removeTime&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (removeTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 分页删除，以免批量太大报错</span></span><br><span class="line">                        persistService.removeConfigHistory(startTime, pageSize);</span><br><span class="line">                        removeTime--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"clearConfigHistory error"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.将数据库配置信息加载到本地文件以及缓存md5（不包含beta、tag）</span></span><br><span class="line">        dumpConfigInfo(dumpAllProcessor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.加载beta缓存</span></span><br><span class="line">        LogUtil.defaultLog.info(<span class="string">"start clear all config-info-beta."</span>);</span><br><span class="line">        DiskUtil.clearAllBeta();</span><br><span class="line">        <span class="keyword">if</span> (persistService.isExistTable(BETA_TABLE_NAME)) &#123;</span><br><span class="line">            dumpAllBetaProcessor.process(DumpAllBetaTask.TASK_ID, <span class="keyword">new</span> DumpAllBetaTask());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.加载带tag的配置数据</span></span><br><span class="line">        LogUtil.defaultLog.info(<span class="string">"start clear all config-info-tag."</span>);</span><br><span class="line">        DiskUtil.clearAllTag();</span><br><span class="line">        <span class="keyword">if</span> (persistService.isExistTable(TAG_TABLE_NAME)) &#123;</span><br><span class="line">            dumpAllTagProcessor.process(DumpAllTagTask.TASK_ID, <span class="keyword">new</span> DumpAllTagTask());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.加载聚合数据</span></span><br><span class="line">        List&lt;ConfigInfoChanged&gt; configList = persistService.findAllAggrGroup();</span><br><span class="line">        <span class="keyword">if</span> (configList != <span class="keyword">null</span> &amp;&amp; !configList.isEmpty()) &#123;</span><br><span class="line">            total = configList.size();</span><br><span class="line">            List&lt;List&lt;ConfigInfoChanged&gt;&gt; splitList = splitList(configList, INIT_THREAD_COUNT);</span><br><span class="line">            <span class="keyword">for</span> (List&lt;ConfigInfoChanged&gt; list : splitList) &#123;</span><br><span class="line">                MergeAllDataWorker work = <span class="keyword">new</span> MergeAllDataWorker(list);</span><br><span class="line">                work.start();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">"server start, schedule merge end."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LogUtil.fatalLog.error(</span><br><span class="line">            <span class="string">"Nacos Server did not start because dumpservice bean construction failure :\n"</span> + e.getMessage(),</span><br><span class="line">            e.getCause());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Nacos Server did not start because dumpservice bean construction failure :\n"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!STANDALONE_MODE) &#123;</span><br><span class="line">        Runnable heartbeat = () -&gt; &#123;</span><br><span class="line">            String heartBeatTime = TimeUtils.getCurrentTime().toString();</span><br><span class="line">            <span class="comment">// write disk</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                DiskUtil.saveHeartBeatToDisk(heartBeatTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                LogUtil.fatalLog.error(<span class="string">"save heartbeat fail"</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 5.定期写heartbeat文件，hearbeat文件记录时间戳用于快速启动</span></span><br><span class="line">        TimerTaskService.scheduleWithFixedDelay(heartbeat, <span class="number">0</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> initialDelay = <span class="keyword">new</span> Random().nextInt(INITIAL_DELAY_IN_MINUTE) + <span class="number">10</span>;</span><br><span class="line">        LogUtil.defaultLog.warn(<span class="string">"initialDelay:&#123;&#125;"</span>, initialDelay);</span><br><span class="line">        <span class="comment">//6. 定期全量dump比对数据</span></span><br><span class="line">        TimerTaskService.scheduleWithFixedDelay(dumpAll, initialDelay, DUMP_ALL_INTERVAL_IN_MINUTE,</span><br><span class="line">            TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//7. 定期全量dump比对beta数据（TODO 此处似乎有bug并没有给dumpAllTaskMgr 添加对应的dumpAllBetaProcessor</span></span><br><span class="line">        TimerTaskService.scheduleWithFixedDelay(dumpAllBeta, initialDelay, DUMP_ALL_INTERVAL_IN_MINUTE,</span><br><span class="line">            TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 8.定期删除数据</span></span><br><span class="line">    TimerTaskService.scheduleWithFixedDelay(clearConfigHistory, <span class="number">10</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="dumpConfigInfo"><a href="#dumpConfigInfo" class="headerlink" title="dumpConfigInfo"></a>dumpConfigInfo</h3><p>dump配置信息存在快速启动和全量dump,当开启快速启动且上一次时间戳距离当前6小时内才会快速启动，否则全量dump</p><blockquote><p> 配置<code>isQuickStart=true</code>开启快速启动，启动后会开启一个线程定期往本地 <code>{NACOSHOME}/nacos/status/heartBeat.txt</code>目录写时间戳，用于下次重启时快速启动</p></blockquote><h4 id="全量dump"><a href="#全量dump" class="headerlink" title="全量dump"></a>全量dump</h4><p>全量dump会清理本地文件 然后从数据库中加载数据到文件，以及对应内容的md5到内存<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DiskUtil.clearAll();</span><br><span class="line">dumpAllProcessor.process(DumpAllTask.TASK_ID, <span class="keyword">new</span> DumpAllTask());</span><br></pre></td></tr></table></figure></p><p>dumpAllProcessor.process 查询所有的配置信息，依次执行dump操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;PersistService.ConfigInfoWrapper&gt; page = persistService.findAllConfigInfoFragment(lastMaxId,PAGE_SIZE);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">boolean</span> result = ConfigService.dump(cf.getDataId(), cf.getGroup(), cf.getTenant(), cf.getContent(),cf.getLastModified(), cf.getType();</span><br></pre></td></tr></table></figure></p><p>ConfigService.dump 将内容写入磁盘,md5信息写入CACHE内存<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (md5.equals(ConfigService.getContentMd5(groupKey))) &#123; <span class="comment">//从 CACHE.get(groupKey); 中获取缓存的md5 启动时势必为空</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!STANDALONE_MODE || PropertyUtil.isStandaloneUseMysql()) &#123;</span><br><span class="line">    DiskUtil.saveToDisk(dataId, group, tenant, content);</span><br><span class="line">&#125;</span><br><span class="line">updateMd5(groupKey, md5, lastModifiedTs); <span class="comment">//groupKey = dataId+groupId+tenantId</span></span><br></pre></td></tr></table></figure></p><h4 id="部分dump"><a href="#部分dump" class="headerlink" title="部分dump"></a>部分dump</h4><p>部分dump下会读取heartBeat.txt 获得上一次写入的时间戳，在此时间基础上往前推6小时 dump检查的起始时间<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpChangeProcessor.process(DumpChangeTask.TASK_ID, <span class="keyword">new</span> DumpChangeTask())</span><br></pre></td></tr></table></figure></p><ol><li>获取所有配置信息检查md5是否变更，变更则更新（写文件md5刷内存）</li><li>从配置信息历史表中查询最近时间内（即上文说的起始时间到当前）删除的配置，删除对应文件以及内存中的信息</li><li>获取指定时间内变更的配置，变更则更新（写文件md5刷内存）（？？？感觉和第一步有重复）</li><li><code>ConfigService.reloadConfig();</code>这一步刷新白名单，（TODO 目前不太确认用途)</li><li><code>TimerTaskService.scheduleWithFixedDelay(checkMd5Task, 0, 12,TimeUnit.HOURS);</code> 开启一个定时任务检查CAHCE和文件中存的md5是否一致，不一致则变更</li></ol><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>通过 dumpConfigInfo 方法加载完数据后会开启多个定时任务</p><ul><li>heartbeatTask 定期写时间戳</li><li>dumpAllTask 定期比对更新所有基础配置</li><li>dumpAllBetaTask 定期比对更新beta配置（TODO此处似乎有bug,事实是更新的基础配置）</li><li>checkMd5Task（在快速启动时开启）</li><li>clearConfigHistoryTask定期删除历史数据</li></ul><h2 id="3-监听服务集群列表"><a href="#3-监听服务集群列表" class="headerlink" title="3. 监听服务集群列表"></a>3. 监听服务集群列表</h2><p>核心类<code>ServerListService</code><br>会开启一个 GetServerListTask 每隔5s获取服务器列表</p><blockquote><p> 当推送配置后，服务端接收到请求首先会写数据库，而后分别向调用所有服务器dataChange接口，使所有服务器（包括自身）从数据库加载刚写入的配置到文件以及内存，并触发客户端response。而此处的ServerListService即用于服务器列表的更新</p></blockquote><p>获取列表逻辑如下：</p><ol><li>如果是单机模式，则直接返回本机ip</li><li>非单机模式，读取配置文件（conf/cluster.conf）中的ip列表</li><li>为获取到ip则从配置好的远端服务器获取</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nacos-启动流程&quot;&gt;&lt;a href=&quot;#Nacos-启动流程&quot; class=&quot;headerlink&quot; title=&quot;Nacos 启动流程&quot;&gt;&lt;/a&gt;Nacos 启动流程&lt;/h1&gt;&lt;p&gt;nacos启动主要流程包含:&lt;/p&gt;
&lt;p&gt;读取配置文件 ⟹ 将数据库中存储
      
    
    </summary>
    
      <category term="云原生" scheme="http://wangweizZZ.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
      <category term="nacos" scheme="http://wangweizZZ.github.io/tags/nacos/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ 生产者</title>
    <link href="http://wangweizZZ.github.io/2019/10/27/rocketmq-client/"/>
    <id>http://wangweizZZ.github.io/2019/10/27/rocketmq-client/</id>
    <published>2019-10-27T01:48:37.000Z</published>
    <updated>2020-06-26T07:52:38.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>用于提交消息,支持</p><h3 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span></span><br><span class="line">            DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">        <span class="comment">// Specify name server addresses.</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><img src="/images/rocketmq/rocketmq-producer-1.png" alt="rocketmq-producer"> </p><ul><li>MQAdmin 创建topic,查找获取Offset，查询消息</li><li>MQProducer 开启关闭，发送消息</li><li>DefaultMQProducer 生产者发送消息默认实现类</li><li>TransactionMQProducer</li></ul><h3 id="DefaultMQProducer"><a href="#DefaultMQProducer" class="headerlink" title="DefaultMQProducer"></a>DefaultMQProducer</h3><blockquote><p>  生产者默认实现类，send方法 线程安全 内部包装 <code>DefaultMQProducerImpl</code> 实现发送消息</p></blockquote><h4 id="内部属性"><a href="#内部属性" class="headerlink" title="内部属性"></a>内部属性</h4><ul><li>send等操作实现类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">transient</span> DefaultMQProducerImpl defaultMQProducerImpl;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者组名</span></span><br><span class="line"><span class="keyword">private</span> String producerGroup;</span><br><span class="line"><span class="comment">//每个topic默认队列数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> defaultTopicQueueNums = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//发送消息超时时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sendMsgTimeout = <span class="number">3000</span>;</span><br><span class="line"><span class="comment">//压缩消息的阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> compressMsgBodyOverHowmuch = <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line"><span class="comment">//同步模式下发送消息重试次数，可能导致重复发送</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> retryTimesWhenSendFailed = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//异步模式下发送消息重试次数，可能导致重复发送</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> retryTimesWhenSendAsyncFailed = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//发送失败后是否用另外一个broker重试</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> retryAnotherBrokerWhenNotStoreOK = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//消息体大小上限</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxMessageSize = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>; <span class="comment">// 4M</span></span><br><span class="line"><span class="comment">//trace </span></span><br><span class="line"><span class="keyword">private</span> TraceDispatcher traceDispatcher = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="DefaultMQProducerImpl"><a href="#DefaultMQProducerImpl" class="headerlink" title="DefaultMQProducerImpl"></a>DefaultMQProducerImpl</h3><blockquote><p>  生产者实际工作类  DefaultMQProducerImpl -&gt; MQProducerInner</p></blockquote><h4 id="内部属性-1"><a href="#内部属性-1" class="headerlink" title="内部属性"></a>内部属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护一个DefaultMQProducer引用，用于获取producerGroup、SendMsgTimeout等信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultMQProducer defaultMQProducer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* topic */</span>, TopicPublishInfo&gt; topicPublishInfoTable =</span><br><span class="line">    <span class="keyword">new</span> ConcurrentHashMap&lt;String, TopicPublishInfo&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;SendMessageHook&gt; sendMessageHookList = <span class="keyword">new</span> ArrayList&lt;SendMessageHook&gt;();</span><br><span class="line"><span class="keyword">protected</span> BlockingQueue&lt;Runnable&gt; checkRequestQueue;</span><br><span class="line"><span class="keyword">protected</span> ExecutorService checkExecutor;</span><br><span class="line"><span class="comment">//内部消息发送类</span></span><br><span class="line"><span class="keyword">private</span> MQClientInstance mQClientFactory;</span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;CheckForbiddenHook&gt; checkForbiddenHookList = <span class="keyword">new</span> ArrayList&lt;CheckForbiddenHook&gt;();</span><br><span class="line"><span class="comment">//根据发送broker的延迟选择对应queue</span></span><br><span class="line"><span class="keyword">private</span> MQFaultStrategy mqFaultStrategy = <span class="keyword">new</span> MQFaultStrategy();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; asyncSenderThreadPoolQueue;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService defaultAsyncSenderExecutor;</span><br><span class="line"><span class="keyword">private</span> ExecutorService asyncSenderExecutor;</span><br></pre></td></tr></table></figure><h4 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h4><blockquote><p>sendDefaultImpl 发送消息</p><ol><li>检查消息 <code>Validators.checkMessage(msg, this.defaultMQProducer);</code></li><li>查询 topic路由信息（未获得信息则从调用<code>MQClientInstance#updateTopicRouteInfoFromNameServer</code>获取对应topic路由信息）</li><li>调用<code>MQFaultStrategy#selectOneMessageQueue(tpInfo, lastBrokerName)</code>获得对应<code>MessageQueue</code>发送消息队列，</li></ol></blockquote><ol start="4"><li>调用<code>sendKernelImpl()</code> ，通过<code>MQClientAPIImpl</code> 内部的<code>MQClientAPIImpl</code>发送<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(...)</span><br></pre></td></tr></table></figure></li></ol><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><ol><li><p>从<code>MQClientManager</code>中获取获取一个<code>MQClientInstance</code>实例，<br>(<code>MQClientManager</code>内部维护一个<code>factoryTable</code>，以<code>clientIP</code>+<code>instanceName</code>+<code>unitName</code>为key复用<code>MQClientInstance</code>)</p></li><li><p>注册到 MQClientInstance 上，同一jvm，producerGroup只能注册一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> registerOK = mQClientFactory.registerProducer(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup(), <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line"><span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer group["</span> + <span class="keyword">this</span>.defaultMQProducer.getProducerGroup()</span><br><span class="line">    + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">    <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>topicPublishInfoTable 路由信息</p></li><li><code>mQClientFactory.start()</code> 首次会调用启动 <code>MQClientInstance</code></li></ol><h3 id="MQClientInstance"><a href="#MQClientInstance" class="headerlink" title="MQClientInstance"></a>MQClientInstance</h3><blockquote><p>连接mq的客户端</p></blockquote><h4 id="内部属性-2"><a href="#内部属性-2" class="headerlink" title="内部属性"></a>内部属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClientConfig clientConfig;</span><br><span class="line"><span class="comment">//producer group name和 DefaultMQProducerImpl 的映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* group */</span>, MQProducerInner&gt; producerTable = <span class="keyword">new</span> ConcurrentHashMap&lt;String, MQProducerInner&gt;();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* group */</span>, MQAdminExtInner&gt; adminExtTable = <span class="keyword">new</span> ConcurrentHashMap&lt;String, MQAdminExtInner&gt;();</span><br><span class="line"><span class="comment">//netty配置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> NettyClientConfig nettyClientConfig;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MQClientAPIImpl mQClientAPIImpl;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MQAdminImpl mQAdminImpl;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* Topic */</span>, TopicRouteData&gt; topicRouteTable = <span class="keyword">new</span> ConcurrentHashMap&lt;String, TopicRouteData&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lockNamesrv = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lockHeartbeat = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* Broker Name */</span>, HashMap&lt;Long<span class="comment">/* brokerId */</span>, String<span class="comment">/* address */</span>&gt;&gt; brokerAddrTable =</span><br><span class="line">    <span class="keyword">new</span> ConcurrentHashMap&lt;String, HashMap&lt;Long, String&gt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* Broker Name */</span>, HashMap&lt;String<span class="comment">/* address */</span>, Integer&gt;&gt; brokerVersionTable =</span><br><span class="line">    <span class="keyword">new</span> ConcurrentHashMap&lt;String, HashMap&lt;String, Integer&gt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(<span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"MQClientFactoryScheduledThread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClientRemotingProcessor clientRemotingProcessor;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PullMessageService pullMessageService;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RebalanceService rebalanceService;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultMQProducer defaultMQProducer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConsumerStatsManager consumerStatsManager;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong sendHeartbeatTimesTotal = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">private</span> ServiceState serviceState = ServiceState.CREATE_JUST;</span><br><span class="line"><span class="keyword">private</span> DatagramSocket datagramSocket;</span><br></pre></td></tr></table></figure><h3 id="MQFaultStrategy"><a href="#MQFaultStrategy" class="headerlink" title="MQFaultStrategy"></a>MQFaultStrategy</h3><p>内部包含 <code>LatencyFaultToleranceImpl</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LatencyFaultTolerance&lt;String&gt; latencyFaultTolerance = <span class="keyword">new</span> LatencyFaultToleranceImpl();</span><br></pre></td></tr></table></figure></p><ul><li>LatencyFaultToleranceImpl<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护每个Broker的发送消息的延迟</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, FaultItem&gt; faultItemTable = <span class="keyword">new</span> ConcurrentHashMap&lt;String, FaultItem&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">//通过theadLocal方式记录当前选中的broker，如果执行失败后选择+1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocalIndex whichItemWorst = <span class="keyword">new</span> ThreadLocalIndex();</span><br></pre></td></tr></table></figure></li></ul><h4 id="重要方法-1"><a href="#重要方法-1" class="headerlink" title="重要方法"></a>重要方法</h4><blockquote><p><code>selectOneMessageQueue</code></p><ul><li>当<code>sendLatencyFaultEnable=true</code></li></ul><ol><li>返回一个broker==lastBrokerName</li><li>如果第1步没找到，则</li><li></li></ol></blockquote><ul><li>当<code>sendLatencyFaultEnable=false</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;用于提交消息,支持&lt;/p&gt;
&lt;h3 id=&quot;调用示例&quot;&gt;&lt;a href=&quot;#调用示例&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="消息队列" scheme="http://wangweizZZ.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="rocketmq" scheme="http://wangweizZZ.github.io/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ NameServer</title>
    <link href="http://wangweizZZ.github.io/2019/10/21/rocketmq-nameserver/"/>
    <id>http://wangweizZZ.github.io/2019/10/21/rocketmq-nameserver/</id>
    <published>2019-10-21T01:48:37.000Z</published>
    <updated>2019-10-27T09:17:14.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol><li>Brokers 定期更新metadata</li><li>提供客户端(包含生产者，消费者) 最新路由信息</li></ol><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><blockquote><p>NamesrvController 包含 KVConfigManager、RouteInfoManager、NamesrvConfig、NettyServerConfig等组件</p></blockquote><h3 id="KVConfigManager"><a href="#KVConfigManager" class="headerlink" title="KVConfigManager"></a>KVConfigManager</h3><p>kv键值对管理 ,内部维护一个HashMap支持数据持久化到文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String<span class="comment">/* Namespace */</span>, HashMap&lt;String<span class="comment">/* Key */</span>, String<span class="comment">/* Value */</span>&gt;&gt; configTable =</span><br><span class="line">    <span class="keyword">new</span> HashMap&lt;String, HashMap&lt;String, String&gt;&gt;();</span><br></pre></td></tr></table></figure></p><h3 id="RouteInfoManager"><a href="#RouteInfoManager" class="headerlink" title="RouteInfoManager"></a>RouteInfoManager</h3><p>存储broker列表，topic信息，通过注册<code>BrokerHousekeepingService</code>到netty 处理链上处理对应连接关闭、Idle事件</p><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><blockquote><p>NamesrvStartup.main()</p></blockquote><ol><li>创建 NamesrvController ，传入 NamesrvConfig、NettyServerConfig</li><li>controller.initialize() <ul><li>kvConfigManager 加载配置</li><li>NettyRemotingServer 初始化</li><li>注册netty处理逻辑</li><li>开启间隔10s的定时任务 调用<code>routeInfoManager</code>扫描不可用的broker 关闭channel</li><li>开启间隔10s的定时任务 调用<code>kvConfigManager</code>打印配置信息</li><li>ssl模式下对文件ssl文件监控，变化则调用<code>reloadServerSslContext()</code>刷新Sslcontext</li></ul></li><li>controller.start()<ul><li><code>NettyRemotingServer</code> start()</li><li>ssl模式文件监控开启</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Brokers 定期更新metadata&lt;/li&gt;
&lt;li&gt;提供客户端(包含生产者，消费者) 最新路由信息&lt;/li&gt;
&lt;/ol&gt;
      
    
    </summary>
    
      <category term="消息队列" scheme="http://wangweizZZ.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="rocketmq" scheme="http://wangweizZZ.github.io/tags/rocketmq/"/>
    
      <category term="源码学习" scheme="http://wangweizZZ.github.io/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Spark学习 RPC</title>
    <link href="http://wangweizZZ.github.io/2019/03/18/Spark%E5%AD%A6%E4%B9%A0-RPC/"/>
    <id>http://wangweizZZ.github.io/2019/03/18/Spark学习-RPC/</id>
    <published>2019-03-18T13:54:24.000Z</published>
    <updated>2019-10-29T03:47:58.763Z</updated>
    
    <content type="html"><![CDATA[<p>包含spark-network-common模块和spark-core中rpc部分</p><h1 id="组件架构"><a href="#组件架构" class="headerlink" title="组件架构"></a>组件架构</h1><p><img src="/images/spark/spark-total.png" alt="spark各组件图"></p><hr><h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><h2 id="spark-network-common-部分"><a href="#spark-network-common-部分" class="headerlink" title="spark-network-common 部分"></a>spark-network-common 部分</h2><h3 id="TransportContext"><a href="#TransportContext" class="headerlink" title="TransportContext"></a>TransportContext</h3><p>传输上下文，包含 TransportConf配置信息，可创建TransportServer以及TransportClientFactory</p><ul><li>TransportConf<br>配置文件</li><li>RpcHandler<br>处理请求的netty handler<br>用于TransportClientFactory 创建TransportClient时调用initializePipeline方法包装成 TransportChannelHandler，TransportChannelHandler内部调用RpcHandler处理请求</li></ul><h3 id="TransportClientFactory"><a href="#TransportClientFactory" class="headerlink" title="TransportClientFactory"></a>TransportClientFactory</h3><p>用于创建客户端连接的工厂类<br><code>createClient()</code> 方法用于创建nio客户端，并生成持有客户端Channel的TransportClient</p><p>通过内部的<code>ClientPool</code>维护<code>TransportClient</code>数组<br>通过传入的<code>TransportContext</code>和<code>TransportClientBootstrap</code>创建<code>TransportClient</code>，均用于通过netty pipeline绑定 RpcHandler 、身份验证</p><h3 id="TransportServer"><a href="#TransportServer" class="headerlink" title="TransportServer"></a>TransportServer</h3><p>服务器端<br>启动一个netty服务,类似<code>TransportClientFactory</code>当建立连接后创建一个<code>TransportClient</code>用于处理后续操作</p><h3 id="TransportClient"><a href="#TransportClient" class="headerlink" title="TransportClient"></a>TransportClient</h3><p>通过持有对应连接<code>Channel</code>用于客户端服务端间消息发送</p><hr><h2 id="Spark-core-中RPC部分"><a href="#Spark-core-中RPC部分" class="headerlink" title="Spark-core 中RPC部分"></a>Spark-core 中RPC部分</h2><p>spark-core中的部分用于替换之前的akka。类似akka的actor模型</p><h3 id="RpcEndpoint"><a href="#RpcEndpoint" class="headerlink" title="RpcEndpoint"></a>RpcEndpoint</h3><p>代表具体的通信节点</p><h3 id="RpcEndPointRef"><a href="#RpcEndPointRef" class="headerlink" title="RpcEndPointRef"></a>RpcEndPointRef</h3><p>是对远程RpcEndpoint的一个引用，参考akka中actor模型设计</p><h3 id="RpcEnv"><a href="#RpcEnv" class="headerlink" title="RpcEnv"></a>RpcEnv</h3><p>作为rpc的环境 <code>RpcEndpoint</code> 注册到该对象上<br>通过 <code>new NettyRpcEnvFactory().create(config)</code> 创建具体的实现类<code>NettyRpcEnv</code></p><hr><h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><h3 id="1-StreamManager"><a href="#1-StreamManager" class="headerlink" title="1.StreamManager"></a>1.StreamManager</h3><p><code>NettyStreamManager</code> 用于提供NettyRpcEnv的文件流服务，可注册 文件、jar包和目录 三种资源，可以用来处理StreamRequest类型的消息</p><hr><h1 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h1><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p><img src="/images/spark/spark-server.png" alt="server处理流程图"><br>注册到netty 管道上的 NettyRpcHandler 投递消息到对应endpoints的inbox中 然后<br>dispatcher中的MessageLoop调用endpoint.receiveAndReply返回消息 </p><h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p><img src="/images/spark/spark-client.png" alt="client处理流程图"></p><p><code>RpcEndpointRef</code>调用<code>NettyRpcEnv</code>中 send、ask 方法.<br>当请求地址与本地地址相同时，调用 Dispatcher.postLocalMessage，投递到对应的inbox中，dispatcher内部的线程池 调用endpoint做处理</p><p>当请求地址与本地地址不同时，调用 postToOutbox 投递到对应的outbox 通过TransportClient 发送消息到远端</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;包含spark-network-common模块和spark-core中rpc部分&lt;/p&gt;
&lt;h1 id=&quot;组件架构&quot;&gt;&lt;a href=&quot;#组件架构&quot; class=&quot;headerlink&quot; title=&quot;组件架构&quot;&gt;&lt;/a&gt;组件架构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/im
      
    
    </summary>
    
      <category term="大数据" scheme="http://wangweizZZ.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="源码学习" scheme="http://wangweizZZ.github.io/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="spark" scheme="http://wangweizZZ.github.io/tags/spark/"/>
    
  </entry>
  
</feed>
