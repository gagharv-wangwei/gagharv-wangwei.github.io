<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gagharv</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gagharv-wangwei.github.io/"/>
  <updated>2019-03-29T15:12:50.028Z</updated>
  <id>http://gagharv-wangwei.github.io/</id>
  
  <author>
    <name>wang wei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spark学习 RPC</title>
    <link href="http://gagharv-wangwei.github.io/2019/03/18/Spark%E6%BA%90%E7%A0%81/"/>
    <id>http://gagharv-wangwei.github.io/2019/03/18/Spark源码/</id>
    <published>2019-03-18T13:54:24.000Z</published>
    <updated>2019-03-29T15:12:50.028Z</updated>
    
    <content type="html"><![CDATA[<p>包含spark-network-common模块和spark-core中rpc部分</p><h1 id="组件架构"><a href="#组件架构" class="headerlink" title="组件架构"></a>组件架构</h1><p><img src="/images/spark-total.png" alt="spark各组件图"></p><hr><h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><h2 id="spark-network-common-部分"><a href="#spark-network-common-部分" class="headerlink" title="spark-network-common 部分"></a>spark-network-common 部分</h2><h3 id="TransportContext"><a href="#TransportContext" class="headerlink" title="TransportContext"></a>TransportContext</h3><p>传输上下文，包含 TransportConf配置信息，可创建TransportServer以及TransportClientFactory</p><ul><li>TransportConf<br>配置文件</li><li>RpcHandler<br>处理请求的netty handler<br>用于TransportClientFactory 创建TransportClient时调用initializePipeline方法包装成 TransportChannelHandler，TransportChannelHandler内部调用RpcHandler处理请求</li></ul><h3 id="TransportClientFactory"><a href="#TransportClientFactory" class="headerlink" title="TransportClientFactory"></a>TransportClientFactory</h3><p>用于创建客户端连接的工厂类<br><code>createClient()</code> 方法用于创建nio客户端，并生成持有客户端Channel的TransportClient</p><p>通过内部的<code>ClientPool</code>维护<code>TransportClient</code>数组<br>通过传入的<code>TransportContext</code>和<code>TransportClientBootstrap</code>创建<code>TransportClient</code>，均用于通过netty pipeline绑定 RpcHandler 、身份验证</p><h3 id="TransportServer"><a href="#TransportServer" class="headerlink" title="TransportServer"></a>TransportServer</h3><p>服务器端<br>启动一个netty服务,类似<code>TransportClientFactory</code>当建立连接后创建一个<code>TransportClient</code>用于处理后续操作</p><h3 id="TransportClient"><a href="#TransportClient" class="headerlink" title="TransportClient"></a>TransportClient</h3><p>通过持有对应连接<code>Channel</code>用于客户端服务端间消息发送</p><hr><h2 id="Spark-core-中RPC部分"><a href="#Spark-core-中RPC部分" class="headerlink" title="Spark-core 中RPC部分"></a>Spark-core 中RPC部分</h2><p>spark-core中的部分用于替换之前的akka。类似akka的actor模型</p><h3 id="RpcEndpoint"><a href="#RpcEndpoint" class="headerlink" title="RpcEndpoint"></a>RpcEndpoint</h3><p>代表具体的通信节点</p><h3 id="RpcEndPointRef"><a href="#RpcEndPointRef" class="headerlink" title="RpcEndPointRef"></a>RpcEndPointRef</h3><p>是对远程RpcEndpoint的一个引用，参考akka中actor模型设计</p><h3 id="RpcEnv"><a href="#RpcEnv" class="headerlink" title="RpcEnv"></a>RpcEnv</h3><p>作为rpc的环境 <code>RpcEndpoint</code> 注册到该对象上<br>通过 <code>new NettyRpcEnvFactory().create(config)</code> 创建具体的实现类<code>NettyRpcEnv</code></p><hr><h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><h3 id="1-StreamManager"><a href="#1-StreamManager" class="headerlink" title="1.StreamManager"></a>1.StreamManager</h3><p><code>NettyStreamManager</code> 用于提供NettyRpcEnv的文件流服务，可注册 文件、jar包和目录 三种资源，可以用来处理StreamRequest类型的消息</p><hr><h1 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h1><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p><img src="/images/spark-server.png" alt="server处理流程图"><br>注册到netty 管道上的 NettyRpcHandler 投递消息到对应endpoints的inbox中 然后<br>dispatcher中的MessageLoop调用endpoint.receiveAndReply返回消息 </p><h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p><img src="/images/spark-client.png" alt="client处理流程图"></p><p><code>RpcEndpointRef</code>调用<code>NettyRpcEnv</code>中 send、ask 方法.<br>当请求地址与本地地址相同时，调用 Dispatcher.postLocalMessage，投递到对应的inbox中，dispatcher内部的线程池 调用endpoint做处理</p><p>当请求地址与本地地址不同时，调用 postToOutbox 投递到对应的outbox 通过TransportClient 发送消息到远端</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;包含spark-network-common模块和spark-core中rpc部分&lt;/p&gt;
&lt;h1 id=&quot;组件架构&quot;&gt;&lt;a href=&quot;#组件架构&quot; class=&quot;headerlink&quot; title=&quot;组件架构&quot;&gt;&lt;/a&gt;组件架构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/im
      
    
    </summary>
    
      <category term="大数据" scheme="http://gagharv-wangwei.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="spark" scheme="http://gagharv-wangwei.github.io/tags/spark/"/>
    
  </entry>
  
</feed>
